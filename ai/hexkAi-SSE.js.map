{"version":3,"sources":["../../src/ai/hexkAi-SSE.js"],"names":[],"mappings":"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","file":"hexkAi-SSE.js","sourcesContent":["import { writeFileSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\nimport { readfile } from 'sbg-utility';\n\nconst __filename = fileURLToPath(import.meta.url);\n\n/**\n * Cleans up joined SSE content into a human-readable string.\n *\n * @param {string[]} content - Array of lines.\n * @returns {string} - Cleaned string.\n */\nexport function cleanContent(content) {\n  return content\n    .join(' ')\n    .replace(/\\s+([.,:;!?])/g, '$1') // Remove space before punctuation\n    .replace(/`{2,}/g, '```') // Normalize triple backticks\n    .replace(/\\s*`+\\s*/g, '`') // Trim spaces around `\n    .replace(/\\s+’\\s+/g, '’') // Normalize smart quotes\n    .replace(/\\b’\\s+s\\b/g, '’s') // Fix `’ s` to `’s`\n    .replace(/’\\s+/g, '’') // Remove space after quote\n    .replace(/\\s{2,}/g, ' ') // Collapse multiple spaces\n    .trim();\n}\n\n/**\n * Extracts a section of content between two tags in raw SSE text.\n *\n * @param {string} raw - Raw SSE string.\n * @param {string} startTag - Start tag like '[ANSWER_START]'.\n * @param {string} endTag - End tag like '[ANSWER_DONE]'.\n * @returns {string[]} - Lines between the tags.\n */\nfunction extractSection(raw, startTag, endTag) {\n  const lines = Array.isArray(raw) ? raw : raw.split(/\\r?\\n/).map((line) => line.replace(/^data:\\s?/, ''));\n\n  const start = lines.indexOf(startTag);\n  const end = lines.indexOf(endTag);\n  return start !== -1 && end !== -1 && end > start ? lines.slice(start + 1, end).filter(Boolean) : [];\n}\n\n/**\n * Extracts the raw answer and formats it with code block if present.\n *\n * @param {string | string[]} input - Raw SSE string or pre-parsed lines.\n * @returns {string} - Cleaned and formatted answer.\n */\nexport function extractAnswerCodeblock(input) {\n  if (typeof input === 'string') {\n    input = input.split(/\\r?\\n/);\n  }\n  input = input.map((line) => line.replace(/^data:\\s?/, ''));\n  // console.log('Extracting answer codeblock from input:', input);\n\n  const start = input.indexOf('[ANSWER_START]');\n  const end = input.indexOf('[ANSWER_DONE]');\n  if (start === -1 || end === -1 || end <= start) return '';\n\n  let result = '';\n  const answerLines = input.slice(start + 1, end);\n  for (let i = 0; i < answerLines.length; i++) {\n    const item = answerLines[i];\n    // Check for code block start\n    const isCodeBlock = answerLines[i] == '``' && answerLines[i + 2] == '`';\n    if (isCodeBlock) {\n      result += '\\n```\\n';\n      i += 2; // Skip the next two entries (i+1 and i+2)\n      continue;\n    }\n    // Check for space before punctuation\n    if (item == '-') {\n      if (answerLines[i - 1] == '' && answerLines[i - 2] == '') {\n        result += '\\n' + item;\n        continue;\n      }\n      // console.log(\n      //   `[extractAnswerCodeblock] Dash found in item at index ${i}: \"${item}\". Previous items: \"${answerLines[i - 1]}\", \"${answerLines[i - 2]}\", \"${answerLines[i - 3]}\"`\n      // );\n    }\n    result += item;\n  }\n  // Write result and answerLines to .cache/ai as log files\n  writeFileSync('.cache/ai/answerResult.log', result, 'utf8');\n  writeFileSync('.cache/ai/answerLines.log', answerLines.join('\\n'), 'utf8');\n\n  return result;\n}\n\n/**\n * Extracts the answer section from raw SSE content as plain text.\n *\n * @param {string} raw - Raw SSE string.\n * @returns {string} - The extracted answer.\n */\nexport function extractAnswer(raw) {\n  return extractSection(raw, '[ANSWER_START]', '[ANSWER_DONE]').join(' ');\n}\n\n/**\n * Extracts related questions section from raw SSE content.\n *\n * @param {string} raw - Raw SSE string.\n * @returns {string[]} - Related questions as an array.\n */\nexport function extractRelatedQuestions(raw) {\n  return extractSection(raw, '[RELATE_Q_START]', '[RELATE_Q_DONE]');\n}\n\n/**\n * Parses raw SSE content into structured sections.\n *\n * @param {string} raw - Raw SSE string.\n * @returns {{ answer: string, relatedQuestions: string[] }} Parsed result.\n */\nexport function parseSSE(raw) {\n  return {\n    answer: extractAnswer(raw),\n    relatedQuestions: extractRelatedQuestions(raw)\n  };\n}\n\n// CLI entry point\nif (process.argv[1] === __filename) {\n  const read = readfile('.cache/ai/lines.json');\n  const array = JSON.parse(read ?? '[]');\n  const answer = extractAnswerCodeblock(array);\n  console.log(answer, '\\n\\n', array);\n}\n"]}