{"version":3,"sources":["../src/beep.js"],"names":[],"mappings":";;;;;;;;;;;;AAcA,MAAM,SAAA,GAAY,UAAU,IAAI,CAAA;AAChC,MAAM,SAAA,GAAY,EAAA,CAAG,QAAA,EAAS,KAAM,OAAA;AAEpC,MAAM,WAAW,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,GAAA,IAAO,QAAQ,CAAA;AAClD,SAAA,CAAU,QAAA,EAAU,EAAE,SAAA,EAAW,IAAA,EAAM,CAAA;AAEvC,MAAM,UAAA,GAAa,IAAA,CAAK,IAAA,CAAK,QAAA,EAAU,QAAQ,CAAA;AAC/C,MAAM,cAAc,IAAA,CAAK,IAAA,CAAK,QAAA,EAAU,SAAA,GAAY,cAAc,eAAe,CAAA;AAQjF,SAAS,YAAA,GAAe;AACtB,EAAA,MAAM,QAAA,GAAW,GAAG,QAAA,EAAS;AAC7B,EAAA,MAAM,IAAA,GAAO,GAAG,IAAA,EAAK;AAErB,EAAA,IAAI,aAAa,OAAA,EAAS;AACxB,IAAA,OAAO,uDAAA;AAAA,EACT;AAEA,EAAA,IAAI,aAAa,OAAA,EAAS;AACxB,IAAA,IAAI,SAAS,OAAA,EAAS;AACpB,MAAA,OAAO,8EAAA;AAAA,IACT;AAGA,IAAA,IAAI,IAAA,KAAS,KAAA,IAAS,IAAA,KAAS,QAAA,EAAU;AAEvC,MAAA,MAAM,UAAA,GAAa,GAAG,IAAA,EAAK;AAE3B,MAAA,IAAI,UAAA,CAAW,QAAA,CAAS,IAAI,CAAA,EAAG;AAC7B,QAAA,OAAO,8EAAA;AAAA,MACT,CAAA,MAAO;AACL,QAAA,OAAO,8EAAA;AAAA,MACT;AAAA,IACF;AAEA,IAAA,QAAQ,IAAA;AAAM,MACZ,KAAK,KAAA;AACH,QAAA,OAAO,8EAAA;AAAA,MACT,KAAK,MAAA;AACH,QAAA,OAAO,6EAAA;AAAA,MACT;AACE,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,gCAAA,EAAmC,IAAI,CAAA,CAAE,CAAA;AAAA;AAC7D,EACF;AAEA,EAAA,IAAI,aAAa,QAAA,EAAU;AACzB,IAAA,MAAM,IAAI,MAAM,6EAA6E,CAAA;AAAA,EAC/F;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sCAAA,EAAyC,QAAQ,CAAA,CAAA,EAAI,IAAI,CAAA,CAAE,CAAA;AAC7E;AASA,eAAe,YAAA,CAAa,KAAK,UAAA,EAAY;AAC3C,EAAA,MAAM,GAAA,GAAM,MAAM,KAAA,CAAM,EAAE,KAAK,MAAA,EAAQ,KAAA,EAAO,YAAA,EAAc,QAAA,EAAU,CAAA;AACtE,EAAA,MAAM,QAAA,CAAS,GAAA,CAAI,IAAA,EAAM,iBAAA,CAAkB,UAAU,CAAC,CAAA;AACxD;AASA,eAAe,cAAA,CAAe,SAAS,WAAA,EAAa;AAClD,EAAA,IAAI,SAAA,EAAW;AACb,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;AAEtC,MAAA,MAAM,MAAA,GAAS,OAAO,WAAA,CAAY,OAAA,EAAS,aAAa,EAAE,IAAA,EAAM,SAAS,CAAA;AACzE,MAAA,MAAA,CAAO,EAAA,CAAG,OAAO,OAAO,CAAA;AACxB,MAAA,MAAA,CAAO,EAAA,CAAG,SAAS,MAAM,CAAA;AAAA,IAC3B,CAAC,CAAA;AAAA,EACH,CAAA,MAAO;AACL,IAAA,SAAA,CAAU,WAAA,EAAa,EAAE,SAAA,EAAW,IAAA,EAAM,CAAA;AAC1C,IAAA,MAAM,SAAA,CAAU,CAAA,SAAA,EAAY,OAAO,CAAA,MAAA,EAAS,WAAW,CAAA,CAAA,CAAG,CAAA;AAAA,EAC5D;AACF;AASA,SAAS,eAAe,IAAA,EAAM;AAC5B,EAAA,MAAM,OAAA,GAAU,YAAY,YAAA,GAAe,QAAA;AAG3C,EAAA,MAAM,OAAA,GAAU,IAAA,CAAK,IAAA,CAAK,CAAA,OAAA,EAAU,OAAO,CAAA,CAAA,EAAI,EAAE,GAAA,EAAK,IAAA,EAAM,QAAA,EAAU,IAAA,EAAM,CAAA;AAE5E,EAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,CAAC,CAAC,CAAA;AAAA,EAChC;AAGA,EAAA,MAAM,OAAA,GAAU,GACb,WAAA,CAAY,IAAA,EAAM,EAAE,aAAA,EAAe,IAAA,EAAM,CAAA,CACzC,MAAA,CAAO,CAAC,MAAA,KAAW,MAAA,CAAO,aAAa,CAAA,CACvC,IAAI,CAAC,MAAA,KAAW,OAAO,IAAI,CAAA;AAE9B,EAAA,KAAA,MAAW,OAAO,OAAA,EAAS;AACzB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,IAAA,CAAK,IAAA,EAAM,KAAK,KAAK,CAAA;AAC1C,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,OAAA,EAAS,OAAO,CAAA;AACzC,IAAA,IAAI,EAAA,CAAG,UAAA,CAAW,MAAM,CAAA,EAAG;AACzB,MAAA,OAAO,OAAA;AAAA,IACT;AAAA,EACF;AAGA,EAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,IAAA,EAAM,OAAO,CAAA;AACxC,EAAA,IAAI,EAAA,CAAG,UAAA,CAAW,QAAQ,CAAA,EAAG;AAC3B,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,EAAG,OAAO,CAAA,qCAAA,CAAuC,CAAA;AACnE;AAOA,eAAe,aAAA,GAAgB;AAC7B,EAAA,MAAM,YAAY,YAAA,EAAa;AAE/B,EAAA,IAAI,CAAC,EAAA,CAAG,UAAA,CAAW,WAAW,CAAA,EAAG;AAC/B,IAAA,OAAA,CAAQ,IAAI,uBAAuB,CAAA;AACnC,IAAA,MAAM,YAAA,CAAa,WAAW,WAAW,CAAA;AAAA,EAC3C;AAEA,EAAA,IAAI,CAAC,EAAA,CAAG,UAAA,CAAW,UAAU,CAAA,EAAG;AAC9B,IAAA,OAAA,CAAQ,IAAI,sBAAsB,CAAA;AAClC,IAAA,MAAM,cAAA,CAAe,aAAa,UAAU,CAAA;AAAA,EAC9C;AAEA,EAAA,MAAM,SAAA,GAAY,eAAe,UAAU,CAAA;AAC3C,EAAA,OAAA,CAAQ,GAAA,CAAI,IAAA,GAAO,CAAA,EAAG,SAAS,CAAA,EAAG,KAAK,SAAS,CAAA,EAAG,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,CAAA;AACnE,EAAA,OAAO,SAAA;AACT;AAQA,eAAsB,eAAe,MAAA,EAAQ;AAC3C,EAAA,MAAM,QAAA,GAAW,KAAK,QAAA,CAAS,MAAA,CAAO,MAAM,GAAG,CAAA,CAAE,CAAC,CAAC,CAAA;AACnD,EAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,QAAA,EAAU,SAAS,QAAQ,CAAA;AAEtD,EAAA,IAAI,CAAC,EAAA,CAAG,UAAA,CAAW,QAAQ,CAAA,EAAG;AAC5B,IAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,YAAA,EAAe,QAAQ,CAAA,GAAA,CAAK,CAAA;AACxC,IAAA,MAAM,YAAA,CAAa,QAAQ,QAAQ,CAAA;AAAA,EACrC;AAEA,EAAA,MAAM,SAAA,GAAY,MAAM,aAAA,EAAc;AACtC,EAAA,MAAM,SAAA,GAAY,YAAY,YAAA,GAAe,QAAA;AAE7C,EAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,CAAA,EAAG,SAAS,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA,EAAI,CAAC,QAAA,EAAU,SAAA,EAAW,WAAW,CAAA,EAAG;AAAA,IAC3F,QAAA,EAAU,IAAA;AAAA,IACV,KAAA,EAAO,QAAA;AAAA,IACP,WAAA,EAAa;AAAA,GACd,CAAA;AAED,EAAA,aAAA,CAAc,KAAA,EAAM;AAEpB,EAAA,UAAA,CAAW,MAAM;AACf,IAAA,IAAI;AACF,MAAA,aAAA,CAAc,IAAA,EAAK;AAAA,IACrB,SAAS,GAAA,EAAK;AACZ,MAAA,OAAA,CAAQ,KAAA,CAAM,iCAAiC,GAAG,CAAA;AAAA,IACpD;AAAA,EACF,GAAG,GAAI,CAAA;AACT","file":"beep.js","sourcesContent":["import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { mkdirSync } from 'fs';\nimport { spawn } from 'child_process';\nimport { pipeline } from 'stream/promises';\nimport { createWriteStream } from 'fs';\nimport { promisify } from 'util';\nimport { exec } from 'child_process';\nimport node7z from 'node-7z';\nimport * as glob from 'glob';\nimport { path7za } from '7zip-bin';\n\nconst execAsync = promisify(exec);\nconst isWindows = os.platform() === 'win32';\n\nconst cacheDir = path.join(process.cwd(), '.cache');\nmkdirSync(cacheDir, { recursive: true });\n\nconst extractDir = path.join(cacheDir, 'ffmpeg');\nconst archivePath = path.join(cacheDir, isWindows ? 'ffmpeg.7z' : 'ffmpeg.tar.xz');\n\n/**\n * Get the appropriate FFmpeg download URL based on the current platform and architecture.\n *\n * @returns {string} - The URL to download the FFmpeg archive.\n * @throws {Error} - Throws an error if an unsupported platform or architecture is detected.\n */\nfunction getFfmpegUrl() {\n  const platform = os.platform();\n  const arch = os.arch(); // 'x64', 'arm64', etc.\n\n  if (platform === 'win32') {\n    return 'https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z';\n  }\n\n  if (platform === 'linux') {\n    if (arch === 'arm64') {\n      return 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-arm64-static.tar.xz';\n    }\n\n    // Detect ARM architecture and decide between armhf and armel\n    if (arch === 'arm' || arch === 'armv7l') {\n      // Check for ARM hard-float (armhf) or soft-float (armel)\n      const armVersion = os.arch(); // This gives 'arm', 'armv7l', etc.\n\n      if (armVersion.includes('v7')) {\n        return 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-armhf-static.tar.xz'; // armhf\n      } else {\n        return 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-armel-static.tar.xz'; // armel\n      }\n    }\n\n    switch (arch) {\n      case 'x64':\n        return 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz';\n      case 'ia32':\n        return 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-i686-static.tar.xz';\n      default:\n        throw new Error(`Unsupported Linux architecture: ${arch}`);\n    }\n  }\n\n  if (platform === 'darwin') {\n    throw new Error('macOS: Please install FFmpeg using Homebrew or download a universal binary.');\n  }\n\n  throw new Error(`Unsupported platform or architecture: ${platform} ${arch}`);\n}\n\n/**\n * Download a file from a given URL and save it to a specified output path.\n *\n * @param {string} url - The URL to download the file from.\n * @param {string} outputPath - The file path where the downloaded file will be saved.\n * @returns {Promise<void>} - A promise that resolves when the download is complete.\n */\nasync function downloadFile(url, outputPath) {\n  const res = await axios({ url, method: 'GET', responseType: 'stream' });\n  await pipeline(res.data, createWriteStream(outputPath));\n}\n\n/**\n * Extract a downloaded archive to a specified directory.\n *\n * @param {string} archive - The path to the archive file (e.g., .tar.xz or .7z).\n * @param {string} destination - The path where the extracted files will be stored.\n * @returns {Promise<void>} - A promise that resolves when the extraction is complete.\n */\nasync function extractArchive(archive, destination) {\n  if (isWindows) {\n    return new Promise((resolve, reject) => {\n      // Ensure you are importing 'node-7z' and '7zip-bin' correctly\n      const stream = node7z.extractFull(archive, destination, { $bin: path7za });\n      stream.on('end', resolve);\n      stream.on('error', reject);\n    });\n  } else {\n    mkdirSync(destination, { recursive: true });\n    await execAsync(`tar -xf \"${archive}\" -C \"${destination}\"`);\n  }\n}\n\n/**\n * Find the path to the `ffplay` binary within the extracted directory using glob.\n *\n * @param {string} root - The root directory where FFmpeg has been extracted.\n * @returns {string} - The path to the `ffplay` binary directory.\n * @throws {Error} - Throws an error if `ffplay` is not found in the directory.\n */\nfunction findFfplayPath(root) {\n  const binName = isWindows ? 'ffplay.exe' : 'ffplay';\n\n  // Use glob to search for the ffplay binary in subdirectories (with 'bin' as part of the path)\n  const matches = glob.sync(`**/bin/${binName}`, { cwd: root, absolute: true });\n\n  if (matches.length > 0) {\n    return path.dirname(matches[0]); // Return the directory containing the ffplay binary\n  }\n\n  // Legacy method\n  const subdirs = fs\n    .readdirSync(root, { withFileTypes: true })\n    .filter((dirent) => dirent.isDirectory())\n    .map((dirent) => dirent.name);\n\n  for (const dir of subdirs) {\n    const binPath = path.join(root, dir, 'bin');\n    const ffplay = path.join(binPath, binName);\n    if (fs.existsSync(ffplay)) {\n      return binPath;\n    }\n  }\n\n  // Some builds extract directly without subfolders\n  const flatPath = path.join(root, binName);\n  if (fs.existsSync(flatPath)) {\n    return root;\n  }\n\n  throw new Error(`${binName} not found in extracted FFmpeg folder`);\n}\n\n/**\n * Prepare the FFmpeg binaries by downloading, extracting, and setting the PATH for `ffplay`.\n *\n * @returns {Promise<string>} - A promise that resolves to the directory where `ffplay` is located.\n */\nasync function prepareFfplay() {\n  const ffmpegUrl = getFfmpegUrl();\n\n  if (!fs.existsSync(archivePath)) {\n    console.log('Downloading FFmpeg...');\n    await downloadFile(ffmpegUrl, archivePath);\n  }\n\n  if (!fs.existsSync(extractDir)) {\n    console.log('Extracting FFmpeg...');\n    await extractArchive(archivePath, extractDir);\n  }\n\n  const ffplayDir = findFfplayPath(extractDir);\n  process.env.PATH = `${ffplayDir}${path.delimiter}${process.env.PATH}`;\n  return ffplayDir;\n}\n\n/**\n * Play an MP3 file from a URL using `ffplay`.\n *\n * @param {string} mp3Url - The URL of the MP3 file to play.\n * @returns {Promise<void>} - A promise that resolves when the file is playing.\n */\nexport async function playMp3FromUrl(mp3Url) {\n  const filename = path.basename(mp3Url.split('?')[0]);\n  const filePath = path.join(cacheDir, 'audio', filename);\n\n  if (!fs.existsSync(filePath)) {\n    console.log(`Downloading ${filename}...`);\n    await downloadFile(mp3Url, filePath);\n  }\n\n  const ffplayDir = await prepareFfplay();\n  const ffplayBin = isWindows ? 'ffplay.exe' : 'ffplay';\n\n  const ffplayProcess = spawn(`${ffplayDir}/${ffplayBin}`, [filePath, '-nodisp', '-autoexit'], {\n    detached: true,\n    stdio: 'ignore',\n    windowsHide: true\n  });\n\n  ffplayProcess.unref();\n\n  setTimeout(() => {\n    try {\n      ffplayProcess.kill();\n    } catch (err) {\n      console.error('Error killing ffplay process:', err);\n    }\n  }, 5000);\n}\n"]}