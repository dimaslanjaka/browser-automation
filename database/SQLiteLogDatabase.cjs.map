{"version":3,"sources":["../../src/database/SQLiteLogDatabase.js"],"names":["path","fs","Database","moment","cp","jsonStringifyWithCircularRefs","jsonParseWithCircularRefs"],"mappings":"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","file":"SQLiteLogDatabase.cjs","sourcesContent":["import Database from 'better-sqlite3';\nimport cp from 'cross-spawn';\nimport fs from 'fs-extra';\nimport moment from 'moment-timezone';\nimport { jsonParseWithCircularRefs, jsonStringifyWithCircularRefs } from 'sbg-utility';\nimport path from 'upath';\n\nconst cacheDirectoryPath = path.join(process.cwd(), '.cache');\nconst backupDirectoryPath = path.join(cacheDirectoryPath, 'database/backup');\n\n/**\n * Get the absolute file path for a SQLite database file by name.\n * @param {string} name - Database filename without extension.\n * @returns {string} Absolute path to the database file.\n */\nexport function getDatabaseFilePath(name) {\n  return path.resolve(cacheDirectoryPath, `${name}.db`);\n}\n\n/**\n * Class representing a log database using SQLite.\n */\nexport class SQLiteLogDatabase {\n  /**\n   * Create a new LogDatabase instance.\n   * @param {string} [dbFileName] - Optional database filename without extension. Defaults to environment variable DATABASE_FILENAME or 'default'.\n   */\n  constructor(dbFileName) {\n    const name = dbFileName || process.env.DATABASE_FILENAME || 'default';\n    if (!fs.existsSync(cacheDirectoryPath)) fs.mkdirSync(cacheDirectoryPath, { recursive: true });\n\n    const dbPath = getDatabaseFilePath(name);\n    this.dbPath = dbPath;\n    this.db = new Database(dbPath);\n\n    // Auto run backup on process exit\n    process.on('exit', () => {\n      const backupPath = path.join(\n        backupDirectoryPath,\n        `${name}-backup-${moment().tz('Asia/Jakarta').format('YYYYMMDD-HHmmss')}.sql`\n      );\n      this.backup(backupPath).catch((err) => {\n        console.error('Failed to backup database on exit:', err);\n      });\n    });\n  }\n\n  /**\n   * Execute a raw SQL query on the underlying SQLite database.\n   * @param {string} sql - The SQL query string.\n   * @param {any[]} [params] - Optional parameters for the query.\n   * @returns {any} The result of the query.\n   */\n  query(sql, params = []) {\n    return this.db.prepare(sql).all(...params);\n  }\n\n  /**\n   * Close the database connection.\n   */\n  close() {\n    this.db.close();\n    this.db = undefined;\n  }\n\n  /**\n   * Check if the pool is closed.\n   * @returns {boolean}\n   */\n  isClosed() {\n    return !this.db;\n  }\n\n  /**\n   * Backup the SQLite database file to a specified destination (raw SQLite file, not SQL dump).\n   * Uses better-sqlite3's native backup method for reliability and performance.\n   * @param {string} destPath - The destination file path for the backup (will be a binary SQLite file).\n   * @returns {Promise<import('better-sqlite3').BackupMetadata>} Resolves when backup is complete.\n   */\n  async backup(destPath) {\n    fs.ensureDirSync(path.dirname(destPath));\n    // Use cross-spawn to run sqlite3 and dump the database\n    const dumpArgs = [this.dbPath, '.dump'];\n    const outStream = fs.createWriteStream(destPath);\n    // Add process.cwd() + '/bin' to PATH for sqlite3 lookup\n    const env = { ...process.env };\n    const binPath = path.join(process.cwd(), 'bin');\n    env.PATH = `${binPath};${env.PATH}`;\n    const child = cp('sqlite3', dumpArgs, { stdio: ['ignore', 'pipe', 'inherit'], env });\n    child.stdout.pipe(outStream);\n    await new Promise((resolve, reject) => {\n      child.on('error', (err) => {\n        console.error('Backup failed:', err);\n        reject(err);\n      });\n      child.on('close', (code) => {\n        if (code === 0) {\n          console.log('Backup completed:', destPath);\n          resolve();\n        } else {\n          const err = new Error(`Backup failed with exit code ${code}`);\n          console.error(err);\n          reject(err);\n        }\n      });\n    });\n    // Wait for file to be accessible\n    while (\n      await fs\n        .access(destPath)\n        .then(() => false)\n        .catch(() => true)\n    ) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n    // Replace CREATE TABLE statements to ensure compatibility\n    let content = await fs.readFile(destPath, 'utf-8');\n    content = content.replace('CREATE TABLE logs', 'CREATE TABLE IF NOT EXISTS logs');\n    await fs.writeFile(destPath, content, 'utf-8');\n  }\n\n  /**\n   * Initialize the database: set journal mode and create logs table if not exists.\n   * @private\n   */\n  initialize() {\n    this.db.pragma('journal_mode = WAL');\n    this.db\n      .prepare(\n        `CREATE TABLE IF NOT EXISTS logs (\n          id TEXT PRIMARY KEY,\n          data TEXT,\n          message TEXT,\n          timestamp TEXT\n        )`\n      )\n      .run();\n  }\n\n  /**\n   * Add or update a log entry in the database.\n   * @param {import('./BaseLogDatabase').LogEntry} log - Log entry object.\n   */\n  addLog(log) {\n    const timestamp = log.timestamp || moment().tz('Asia/Jakarta').format('YYYY-MM-DDTHH:mm:ssZ');\n    this.db\n      .prepare(`INSERT OR REPLACE INTO logs (id, data, message, timestamp) VALUES (?, ?, ?, ?)`)\n      .run(log.id, jsonStringifyWithCircularRefs(log.data), log.message, timestamp);\n  }\n\n  /**\n   * Remove a log entry by its id.\n   * @param {import('./BaseLogDatabase').LogEntry['id']} id - Unique log identifier.\n   * @returns {boolean} True if a log was removed, false otherwise.\n   */\n  removeLog(id) {\n    const info = this.db.prepare('DELETE FROM logs WHERE id = ?').run(id);\n    return info.changes > 0;\n  }\n\n  /**\n   * Get a log entry by its id.\n   * @param {import('./BaseLogDatabase').LogEntry['id']} id - Unique log identifier.\n   * @returns {import('./BaseLogDatabase').LogEntry | undefined} Log object or undefined if not found.\n   */\n  getLogById(id) {\n    const row = this.db.prepare('SELECT * FROM logs WHERE id = ?').get(id);\n    if (!row) return undefined;\n    return {\n      id: row.id,\n      data: jsonParseWithCircularRefs(row.data),\n      message: row.message,\n      timestamp: row.timestamp\n    };\n  }\n\n  /**\n   * Get all logs or filtered logs from the database.\n   *\n   * @param {(log: import('./BaseLogDatabase').LogEntry) => boolean | Promise<boolean>} [filterFn] Optional filter function to apply to each log entry after fetching from the database.\n   * @param {Object} [options] Optional pagination options.\n   * @param {number} [options.limit] Maximum number of logs to return.\n   * @param {number} [options.offset] Number of logs to skip before starting to collect the result set.\n   * @returns {Array<import('./BaseLogDatabase').LogEntry>} Array of log objects with shape: { id, data, message, timestamp }.\n   */\n  getLogs(filterFn = () => true, options = {}) {\n    let query = 'SELECT * FROM logs';\n    const params = [];\n    if (options?.limit) {\n      query += ' LIMIT ?';\n      params.push(options.limit);\n      if (options.offset) {\n        query += ' OFFSET ?';\n        params.push(options.offset);\n      }\n    }\n    const rows = this.db.prepare(query).all(...params);\n    const logsArr = rows.map((row) => ({\n      id: row.id,\n      data: jsonParseWithCircularRefs(row.data),\n      message: row.message,\n      timestamp: row.timestamp\n    }));\n    return logsArr.filter(filterFn);\n  }\n}\n\n// Example usage:\n// const logDb = new LogDatabase('mydb');\n// logDb.addLog({ id: '123', data: { foo: 'bar' }, message: 'Test log' });\n\n// Backward compatibility\n\n// Default singleton instance (similar to old behavior)\nconst db = new SQLiteLogDatabase(process.env.DATABASE_FILENAME || 'default');\n\n/**\n * Create a new LogDatabase instance at a custom path.\n * @param {string} dbPath - Custom database filename without extension.\n * @returns {SQLiteLogDatabase} LogDatabase instance.\n */\nexport function createLogDatabase(dbPath) {\n  return new SQLiteLogDatabase(dbPath);\n}\n\n/**\n * Backup the singleton log database to a specified destination.\n * @param {string} destPath - The destination file path for the backup.\n * @returns {Promise<void>} Resolves when backup is complete.\n */\nexport function backupLogDatabase(destPath) {\n  return db.backup(destPath);\n}\n\n/* === Re-export old functions for backward compatibility === */\n\n/**\n * Add a log entry (singleton DB).\n * @param {Object} params\n * @param {string} params.id\n * @param {any} params.data\n * @param {string} params.message\n */\nexport function addLog(params) {\n  db.addLog(params);\n}\n\n/**\n * Remove a log entry by id (singleton DB).\n * @param {string} id\n * @returns {boolean}\n */\nexport function removeLog(id) {\n  return db.removeLog(id);\n}\n\n/**\n * Get a log entry by id (singleton DB).\n * @param {string} id\n */\nexport function getLogById(id) {\n  return db.getLogById(id);\n}\n\n/**\n * Get all logs (singleton DB) with optional filter.\n * @param {function({ id: string, data: any, message: string, timestamp: string }): boolean} [filterFn]\n */\nexport function getLogs(filterFn) {\n  return db.getLogs(filterFn);\n}\n"]}