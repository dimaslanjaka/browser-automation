{"version":3,"sources":["../../src/utils/date.js"],"names":["match"],"mappings":";;;AAQO,SAAS,UAAU,OAAA,EAAS;AACjC,EAAA,IAAI,CAAC,OAAA,IAAW,OAAA,CAAQ,IAAA,EAAK,KAAM,IAAI,OAAO,OAAA;AAG9C,EAAA,MAAM,aAAA,GAAgB;AAAA,IACpB,EAAE,OAAA,EAAS,YAAA,EAAc,KAAA,EAAO,+BAAA,EAAgC;AAAA,IAChE,EAAE,OAAA,EAAS,YAAA,EAAc,KAAA,EAAO,+BAAA,EAAgC;AAAA,IAChE,EAAE,OAAA,EAAS,YAAA,EAAc,KAAA,EAAO,iCAAA;AAAkC,GACpE;AAEA,EAAA,KAAA,MAAW,EAAE,OAAA,EAAS,KAAA,EAAM,IAAK,aAAA,EAAe;AAC9C,IAAA,MAAMA,MAAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA;AACjC,IAAA,IAAIA,MAAAA,EAAO;AACT,MAAA,MAAM,MAAA,GAAS,MAAA,CAAO,OAAA,EAAS,OAAA,EAAS,IAAI,CAAA;AAC5C,MAAA,IAAI,MAAA,CAAO,SAAQ,EAAG;AACpB,QAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,QAAA,IAAI,IAAA,IAAQ,QAAQ,IAAA,IAAA,iBAAQ,IAAI,MAAK,EAAE,WAAA,KAAgB,EAAA,EAAI;AACzD,UAAA,OAAO,MAAA,CAAO,OAAO,YAAY,CAAA;AAAA,QACnC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,cAAA,GAAiB,iCAAA;AACvB,EAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,cAAc,CAAA;AAC1C,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,MAAM,GAAG,KAAA,EAAO,MAAM,CAAA,GAAI,KAAA;AAC1B,IAAA,MAAM,QAAA,GAAW,QAAA,CAAS,KAAA,EAAO,EAAE,CAAA;AACnC,IAAA,MAAM,SAAA,GAAY,QAAA,CAAS,MAAA,EAAQ,EAAE,CAAA;AAIrC,IAAA,IAAI,WAAW,EAAA,EAAI;AACjB,MAAA,MAAM,MAAA,GAAS,MAAA,CAAO,OAAA,EAAS,YAAA,EAAc,IAAI,CAAA;AACjD,MAAA,IAAI,MAAA,CAAO,OAAA,EAAQ,IAAK,MAAA,CAAO,MAAK,IAAK,IAAA,IAAQ,MAAA,CAAO,IAAA,uBAAU,IAAI,IAAA,EAAK,EAAE,WAAA,KAAgB,EAAA,EAAI;AAC/F,QAAA,OAAO,MAAA,CAAO,OAAO,YAAY,CAAA;AAAA,MACnC;AAAA,IACF;AAGA,IAAA,IAAI,YAAY,EAAA,EAAI;AAClB,MAAA,MAAM,MAAA,GAAS,MAAA,CAAO,OAAA,EAAS,YAAA,EAAc,IAAI,CAAA;AACjD,MAAA,IAAI,MAAA,CAAO,OAAA,EAAQ,IAAK,MAAA,CAAO,MAAK,IAAK,IAAA,IAAQ,MAAA,CAAO,IAAA,uBAAU,IAAI,IAAA,EAAK,EAAE,WAAA,KAAgB,EAAA,EAAI;AAC/F,QAAA,OAAO,MAAA,CAAO,OAAO,YAAY,CAAA;AAAA,MACnC;AAAA,IACF;AAGA,IAAA,MAAM,UAAA,GAAa,MAAA,CAAO,OAAA,EAAS,YAAA,EAAc,IAAI,CAAA;AACrD,IAAA,IAAI,UAAA,CAAW,OAAA,EAAQ,IAAK,UAAA,CAAW,MAAK,IAAK,IAAA,IAAQ,UAAA,CAAW,IAAA,uBAAU,IAAI,IAAA,EAAK,EAAE,WAAA,KAAgB,EAAA,EAAI;AAC3G,MAAA,OAAO,UAAA,CAAW,OAAO,YAAY,CAAA;AAAA,IACvC;AAGA,IAAA,MAAM,UAAA,GAAa,MAAA,CAAO,OAAA,EAAS,YAAA,EAAc,IAAI,CAAA;AACrD,IAAA,IAAI,UAAA,CAAW,OAAA,EAAQ,IAAK,UAAA,CAAW,MAAK,IAAK,IAAA,IAAQ,UAAA,CAAW,IAAA,uBAAU,IAAI,IAAA,EAAK,EAAE,WAAA,KAAgB,EAAA,EAAI;AAC3G,MAAA,OAAO,UAAA,CAAW,OAAO,YAAY,CAAA;AAAA,IACvC;AAAA,EACF;AAGA,EAAA,OAAO,OAAA;AACT","file":"date.js","sourcesContent":["import moment from 'moment';\n\n/**\n * Automatically detects and parses date format from a string\n * Supports multiple date formats and uses heuristics to distinguish between ambiguous formats\n * @param {string} dateStr - The date string to parse\n * @returns {string} The formatted date in DD/MM/YYYY format, or original string if parsing fails\n */\nexport function parseDate(dateStr) {\n  if (!dateStr || dateStr.trim() === '') return dateStr;\n\n  // First, try formats with unique patterns\n  const uniqueFormats = [\n    { pattern: 'YYYY-MM-DD', regex: /^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/ },\n    { pattern: 'DD-MM-YYYY', regex: /^(\\d{1,2})-(\\d{1,2})-(\\d{4})$/ },\n    { pattern: 'YYYY/MM/DD', regex: /^(\\d{4})\\/(\\d{1,2})\\/(\\d{1,2})$/ }\n  ];\n\n  for (const { pattern, regex } of uniqueFormats) {\n    const match = dateStr.match(regex);\n    if (match) {\n      const parsed = moment(dateStr, pattern, true);\n      if (parsed.isValid()) {\n        const year = parsed.year();\n        if (year >= 1900 && year <= new Date().getFullYear() + 10) {\n          return parsed.format('DD/MM/YYYY');\n        }\n      }\n    }\n  }\n\n  // Handle ambiguous DD/MM/YYYY vs MM/DD/YYYY formats\n  const ambiguousRegex = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const match = dateStr.match(ambiguousRegex);\n  if (match) {\n    const [, first, second] = match;\n    const firstNum = parseInt(first, 10);\n    const secondNum = parseInt(second, 10);\n\n    // Heuristics to determine format:\n    // 1. If first number > 12, it must be DD/MM/YYYY\n    if (firstNum > 12) {\n      const parsed = moment(dateStr, 'DD/MM/YYYY', true);\n      if (parsed.isValid() && parsed.year() >= 1900 && parsed.year() <= new Date().getFullYear() + 10) {\n        return parsed.format('DD/MM/YYYY');\n      }\n    }\n\n    // 2. If second number > 12, it must be MM/DD/YYYY\n    if (secondNum > 12) {\n      const parsed = moment(dateStr, 'MM/DD/YYYY', true);\n      if (parsed.isValid() && parsed.year() >= 1900 && parsed.year() <= new Date().getFullYear() + 10) {\n        return parsed.format('DD/MM/YYYY');\n      }\n    }\n\n    // 3. If both numbers <= 12, try DD/MM/YYYY first (more common format)\n    const ddmmParsed = moment(dateStr, 'DD/MM/YYYY', true);\n    if (ddmmParsed.isValid() && ddmmParsed.year() >= 1900 && ddmmParsed.year() <= new Date().getFullYear() + 10) {\n      return ddmmParsed.format('DD/MM/YYYY');\n    }\n\n    // 4. Fallback to MM/DD/YYYY\n    const mmddParsed = moment(dateStr, 'MM/DD/YYYY', true);\n    if (mmddParsed.isValid() && mmddParsed.year() >= 1900 && mmddParsed.year() <= new Date().getFullYear() + 10) {\n      return mmddParsed.format('DD/MM/YYYY');\n    }\n  }\n\n  // If no format matches, return original\n  return dateStr;\n}\n"]}